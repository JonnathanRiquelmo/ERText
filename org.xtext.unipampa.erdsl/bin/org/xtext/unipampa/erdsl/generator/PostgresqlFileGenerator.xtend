package org.xtext.unipampa.erdsl.generator

import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.unipampa.erdsl.erDsl.ERModel
import org.xtext.unipampa.erdsl.erDsl.Entity
import org.xtext.unipampa.erdsl.erDsl.Relation
import org.xtext.unipampa.erdsl.erDsl.Attribute
import java.util.ArrayList
import java.util.HashMap

/**
* 
* This class serves as a template for the automated generation of a 
* physical schema (<b>PostgreSQL</b>) which is saved as a <b>.sql</b> file in the 
* <b>src-gen</b> folder within the ERtext project.
*
* @author Unipampa/LESSE </br> - Jonnathan Riquelmo: Initial contribution.
* @version 0.4
* @since   0.1 (2019/2)
*/	
class PostgresqlFileGenerator extends AbstractGenerator {
	
	var pkList = new ArrayList<String>()
	var primaryKeys = new ArrayList<Entity>()
	var inheritedPrimaryKeys = new ArrayList<Entity>()
	var primaryKeys_NtoN = new ArrayList
	var primaryKeys_Ternary = new ArrayList
	var mapTernary = new HashMap<String, ArrayList>();
	
	
	var StringBuilder sc_AlterTbl_1to1 = new StringBuilder
	var StringBuilder sc_AlterTbl_1toN = new StringBuilder
	var StringBuilder sc_AlterTbl_NtoN = new StringBuilder
	var StringBuilder sc_AlterTbl_Ternary = new StringBuilder
	
	override doGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) {
	
		val modeloER = input.contents.get(0) as ERModel
	
		try {
			fsa.generateFile(modeloER.domain.name.toLowerCase+'_Postgre.sql', pgsql_CreateModel(modeloER))
		} catch (Exception e) {			
			println(e.stackTrace.toString)
		}	
	}
	
		
	def private pgsql_CreateModel(ERModel modeloER) '''		
	-- PostGreSQL Template generated by ERtext
	
	«pgsql_DomainMapper(modeloER)»
		
	«pgsql_SimpleEntitiesMapper(modeloER)»
	
	«pgsql_NToN_DerivedEntitiesMapper(modeloER)»
	
	«pgsql_TernaryEntitiesMapper(modeloER)»
	
	«pgsql_GeneralizationRefMapper(modeloER)»
	«sc_AlterTbl_1to1.toString»
	«sc_AlterTbl_1to1.length = 0»
	«sc_AlterTbl_1toN.toString»
	«sc_AlterTbl_1toN.length = 0»
	«sc_AlterTbl_NtoN.toString»
	«sc_AlterTbl_NtoN.length = 0»
	«sc_AlterTbl_Ternary.toString»
	«sc_AlterTbl_Ternary.length = 0»
	'''
	
	def private pgsql_DomainMapper (ERModel m) '''
	-- Database: «m.domain.name.toString.toUpperCase»;
	-- CREATE DATABASE «m.domain.name.toString.toUpperCase»;
	--     WITH OWNER = postgres
	--     ENCODING = 'UTF8'
	--     TABLESPACE = pg_default
	--     CONNECTION LIMIT = -1;
	-- DROP DATABASE «m.domain.name.toString.toUpperCase»;
	
	-- DROP TABLE IF EXISTS 
	-- «FOR e : m.entities SEPARATOR ", "»public."«e.name.toLowerCase»"«ENDFOR»«FOR r : m.relations.filter[((leftEnding.cardinality.equalsIgnoreCase('(0:N)') || leftEnding.cardinality.equalsIgnoreCase('(1:N)')) && (rightEnding.cardinality.equalsIgnoreCase('(0:N)') || rightEnding.cardinality.equalsIgnoreCase('(1:N)')))] BEFORE ", " SEPARATOR ", "»public."«r.name.toLowerCase»"«ENDFOR» 
	-- CASCADE;
	'''
	
	def private pgsql_SimpleEntitiesMapper(ERModel m) '''
		«FOR entity : m.entities SEPARATOR " \n);\n" AFTER ");\n"»
			-- Table: «entity.name.toUpperCase»
			«IF !entity.generalization.isNullOrEmpty»
			-- Generalization/Specialization «entity.generalization.toString.toUpperCase» from table «entity.is.toString.toUpperCase»«ENDIF»
			-- DROP TABLE «entity.name.toUpperCase»;	
			CREATE TABLE IF NOT EXISTS «entity.name.toLowerCase» (
				«pgsql_AttributesMapper(m, entity)»
		«ENDFOR»
	'''
		
	def private pgsql_AttributesMapper (ERModel m, Entity e) '''
	«IF e.is !== null»
«««	Check for inheritance and write the inherited key attribute
		«FOR PKInherited : e.is.attributes.filter[isIsKey]»
			«pgsql_AttTypeChecker(PKInherited)»
		«ENDFOR»
		«{this.inheritedPrimaryKeys.add(e.is); null}»
	«ENDIF»
«««	Check if it has its own key attribute and write
	«FOR a : e.attributes.filter[isIsKey]»
		«pgsql_AttTypeChecker(a)»
	«ENDFOR»		
	«{this.primaryKeys.add(e); null}»
«««	Check other descriptive attributes and write
	«FOR a : e.attributes.filter[!isIsKey]»
		«pgsql_AttTypeChecker(a)»
	«ENDFOR»
	«pgsql_1To1_RefCheck(m, e)»
	«pgsql_1ToN_RefCheck(m, e)»
«««	Produces a list of pks with own pks, and found inherited pks.
	«pgsql_MountPkList(primaryKeys, inheritedPrimaryKeys)»
«««	Writes the complete list of pks and then clears the arrays so the same process can be done for other entities without residual traces.
	CONSTRAINT pk_«e.name.toLowerCase» PRIMARY KEY («FOR pks : pkList SEPARATOR ", "»«pks.toLowerCase»«ENDFOR»)
	«{this.primaryKeys.clear; null}»
	«{this.inheritedPrimaryKeys.clear; null}»
	«{this.pkList.clear; null}»
	'''
	
	private def pgsql_MountPkList(ArrayList<Entity> pks, ArrayList<Entity> inheritedPks){
		if (!inheritedPks.isEmpty) {
			for (e : inheritedPks) {
				for (a : e.attributes.filter[isIsKey]) {
					this.pkList.add(a.name.toLowerCase)
				}
			}
		}
		if (!pks.isEmpty) {
			for (e : pks) {
				for (a : e.attributes.filter[isIsKey]) {
					this.pkList.add(a.name.toLowerCase)
				}
			}
		}
	}
	
	
	private def pgsql_AttTypeChecker(Attribute a) '''
		«IF a.type.toString.equalsIgnoreCase("string")»«a.name.toLowerCase» VARCHAR (255) NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("int")»«a.name.toLowerCase» INTEGER NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("datetime")»«a.name.toLowerCase» DATE NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("money")»«a.name.toLowerCase» NUMERIC NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("double")»«a.name.toLowerCase» REAL NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("boolean")»«a.name.toLowerCase» BOOLEAN NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("file")»«a.name.toLowerCase» BYTEA NOT NULL,
		«ENDIF»
	'''
	
	private def pgsql_AttTypeChecker_Unnamed(Attribute a) '''
		«IF a.type.toString.equalsIgnoreCase("string")» VARCHAR (255) NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("int")» INTEGER NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("datetime")» DATE NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("money")» NUMERIC NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("double")» REAL NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("boolean")» BOOLEAN NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("file")» BYTEA NOT NULL,
		«ENDIF»
	'''

	def private pgsql_1To1_RefCheck(ERModel m, Entity e) '''
		«FOR r : m.relations»
			«IF ((r.leftEnding.cardinality.equalsIgnoreCase('(0:1)') || r.leftEnding.cardinality.equalsIgnoreCase('(1:1)'))
			&& 
			(r.rightEnding.cardinality.equalsIgnoreCase('(0:1)') || r.rightEnding.cardinality.equalsIgnoreCase('(1:1)'))) 
			&& r.leftEnding.target instanceof Entity
			&& r.rightEnding.target instanceof Entity»
				«IF r.rightEnding.target.toString.equalsIgnoreCase(e.name)»
«««					Relação: «r.name» | Entidade: «e.name»
					«FOR eAux : m.entities»
						«IF r.leftEnding.target.toString.equalsIgnoreCase(eAux.name)»
«««						Here, the treatment of the first case of relation 1_1 takes place, where the recursive/reflexive relationships are identified.
							«IF e.name.equalsIgnoreCase(eAux.name)»
«««								É AUTORELACIONAMENTO COM «eAux.name»
«««								Being recursive/reflexive relationship, it checks if the entity inherits pks, if true, it looks for the pks of the superclass, adding the name of the relation as a prefix.
								«IF e.is !== null»
									«FOR a : e.is.attributes.filter[isIsKey]»
										«r.name.toLowerCase+"_"+pgsql_AttTypeChecker(a)»
									«ENDFOR»
									«{this.sc_AlterTbl_1to1.append(pgsql_AlterTable_1to1_1toN_RefMapper(e, e.is, r, true, false, false, false, "[1to1]")); null}»
«««									If it is not recursive/reflexive relationship with an entity that inherits pks, it looks for the pks of the recursive/reflexive relationship entity itself, adding the name of the relation as a prefix.
								«ELSEIF e.is === null»
									«FOR a : e.attributes.filter[isIsKey]»
										«r.name.toLowerCase+"_"+pgsql_AttTypeChecker(a)»
									«ENDFOR»
									«{this.sc_AlterTbl_1to1.append(pgsql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, true, false, false, "[1to1]")); null}»
								«ENDIF»
«««								Here happens the treatment of the second case of relation 1_1 when they are not recursive/reflexive relationships.
							«ELSEIF !e.name.equalsIgnoreCase(eAux.name)»
«««								NÃO É AUTORELACIONAMENTO COM «eAux.name»
«««								If the entity being related has inheritance from another, the inherited pks are searched, adding the name of the relation as a prefix.
								«IF eAux.is !== null»
									«FOR a : eAux.is.attributes.filter[isIsKey]»
										«r.name.toLowerCase+"_"+pgsql_AttTypeChecker(a)»
									«ENDFOR»
									«{this.sc_AlterTbl_1to1.append(pgsql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, false, true, false, "[1to1]")); null}»
«««								If the entity being related does not have inheritance, its own pks are searched, adding the name of the relation as a prefix.
								«ELSEIF eAux.is === null»
									«FOR a : eAux.attributes.filter[isIsKey]»
										«r.name.toLowerCase+"_"+pgsql_AttTypeChecker(a)»
									«ENDFOR»
									«{this.sc_AlterTbl_1to1.append(pgsql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, false, false, true, "[1to1]")); null}»
								«ENDIF»
							«ENDIF»
						«ENDIF»
					«ENDFOR»
				«ENDIF» 
			«ENDIF»
		«ENDFOR»
	'''
	
	
	def private pgsql_1ToN_RefCheck(ERModel m, Entity e) '''
		«FOR r : m.relations.filter[((leftEnding.cardinality.equalsIgnoreCase('(0:1)') || leftEnding.cardinality.equalsIgnoreCase('(1:1)'))
				&& 
				(rightEnding.cardinality.equalsIgnoreCase('(0:N)') || rightEnding.cardinality.equalsIgnoreCase('(1:N)'))) 
				&& leftEnding.target instanceof Entity
				&& rightEnding.target instanceof Entity]»
					«IF r.rightEnding.target.toString.equalsIgnoreCase(e.name)»	
«««						Relação: «r.name» | Entidade: «e.name»
						«FOR eAux : m.entities»
							«IF r.leftEnding.target.toString.equalsIgnoreCase(eAux.name)»
«««							Here, the treatment of the first case of relation 1_N takes place, where the recursive/reflexive relationships are identified.
								«IF e.name.equalsIgnoreCase(eAux.name)»
«««									É AUTORELACIONAMENTO COM «eAux.name»
«««									Being recursive/reflexive relationship, it checks if the entity inherits pks, if true, it looks for the pks of the superclass, adding the name of the relation as a prefix.
									«IF e.is !== null»
										«FOR a : e.is.attributes.filter[isIsKey]»
											«r.name.toLowerCase+"_"+pgsql_AttTypeChecker(a)»
										«ENDFOR»
										«{this.sc_AlterTbl_1toN.append(pgsql_AlterTable_1to1_1toN_RefMapper(e, e.is, r, true, false, false, false, "[1toN]")); null}»
«««										If it is not recursive/reflexive relationship with an entity that inherits pks, it looks for the pks of the recursive/reflexive relationship entity itself, adding the name of the relation as a prefix.
									«ELSEIF e.is === null»
										«FOR a : e.attributes.filter[isIsKey]»
											«r.name.toLowerCase+"_"+pgsql_AttTypeChecker(a)»
										«ENDFOR»
										«{this.sc_AlterTbl_1toN.append(pgsql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, true, false, false, "[1toN]")); null}»
									«ENDIF»
«««									Here happens the treatment of the second case of relation 1_N when they are not recursive/reflexive relationships.
								«ELSEIF !e.name.equalsIgnoreCase(eAux.name)»
«««									NÃO É AUTORELACIONAMENTO COM «eAux.name»
«««									If the entity being related has inheritance from another, the inherited pks are searched, adding the name of the relation as a prefix.
									«IF eAux.is !== null»
										«FOR a : eAux.is.attributes.filter[isIsKey]»
											«r.name.toLowerCase+"_"+pgsql_AttTypeChecker(a)»
										«ENDFOR»
										«{this.sc_AlterTbl_1toN.append(pgsql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, false, true, false, "[1toN]")); null}»
«««									If the entity being related does not have inheritance, its own pks are searched, adding the name of the relation as a prefix.
									«ELSEIF eAux.is === null»
										«FOR a : eAux.attributes.filter[isIsKey]»
                                        	«r.name.toLowerCase+"_"+pgsql_AttTypeChecker(a)»
										«ENDFOR»
									«{this.sc_AlterTbl_1toN.append(pgsql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, false, false, true, "[1toN]")); null}»
									«ENDIF»
								«ENDIF»
							«ENDIF»
						«ENDFOR»					
					«ENDIF»
			«ENDFOR»
			«FOR r : m.relations.filter[(((leftEnding.cardinality.equalsIgnoreCase('(0:N)') || leftEnding.cardinality.equalsIgnoreCase('(1:N)'))
				&& 
				(rightEnding.cardinality.equalsIgnoreCase('(0:1)') || rightEnding.cardinality.equalsIgnoreCase('(1:1)'))))
				&& leftEnding.target instanceof Entity 
				&& rightEnding.target instanceof Entity]»
					«IF r.leftEnding.target.toString.equalsIgnoreCase(e.name)»
«««						Relação: «r.name» | Entidade: «e.name»
						«FOR eAux : m.entities»
							«IF r.rightEnding.target.toString.equalsIgnoreCase(eAux.name)»
«««							Here, the treatment of the first case of relation N_1 takes place, where the recursive/reflexive relationships are identified.
								«IF e.name.equalsIgnoreCase(eAux.name)»
«««									É AUTORELACIONAMENTO COM «eAux.name»
«««									Being recursive/reflexive relationship, it checks if the entity inherits pks, if true, it looks for the pks of the superclass, adding the name of the relation as a prefix.
									«IF e.is !== null»
										«FOR a : e.is.attributes.filter[isIsKey]»
                                         	«r.name.toLowerCase+"_"+pgsql_AttTypeChecker(a)»
										«ENDFOR»
										«{this.sc_AlterTbl_1toN.append(pgsql_AlterTable_1to1_1toN_RefMapper(e, e.is, r, true, false, false, false, "[Nto1]")); null}»
«««										If it is not recursive/reflexive relationship with an entity that inherits pks, it looks for the pks of the recursive/reflexive relationship entity itself, adding the name of the relation as a prefix.
									«ELSEIF e.is === null»
										«FOR a : e.attributes.filter[isIsKey]»
                                        	«r.name.toLowerCase+"_"+pgsql_AttTypeChecker(a)»
										«ENDFOR»
										«{this.sc_AlterTbl_1toN.append(pgsql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, true, false, false, "[Nto1]")); null}»
									«ENDIF»
«««									Here happens the treatment of the second case of relation N_1 when they are not recursive/reflexive relationships.
								«ELSEIF !e.name.equalsIgnoreCase(eAux.name)»
«««									NÃO É AUTORELACIONAMENTO COM «eAux.name»
«««									If the entity being related has inheritance from another, the inherited pks are searched, adding the name of the relation as a prefix.
									«IF eAux.is !== null»
										«FOR a : eAux.is.attributes.filter[isIsKey]»
                                        	«r.name.toLowerCase+"_"+pgsql_AttTypeChecker(a)»
										«ENDFOR»
										«{this.sc_AlterTbl_1toN.append(pgsql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, false, true, false, "[Nto1]")); null}»
«««									If the entity being related does not have inheritance, its own pks are searched, adding the name of the relation as a prefix.
									«ELSEIF eAux.is === null»
										«FOR a : eAux.attributes.filter[isIsKey]»
                                        	«r.name.toLowerCase+"_"+pgsql_AttTypeChecker(a)»
										«ENDFOR»
										«{this.sc_AlterTbl_1toN.append(pgsql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, false, false, true, "[Nto1]")); null}»
									«ENDIF»
								«ENDIF»
							«ENDIF»
						«ENDFOR»					
					«ENDIF»
		«ENDFOR»
	'''
	
	//	TODO: Comentar este método por inteiro como os anteriores
	def private pgsql_NToN_DerivedEntitiesMapper(ERModel m)'''
		«FOR r : m.relations.filter[((leftEnding.cardinality.equalsIgnoreCase('(0:N)') || leftEnding.cardinality.equalsIgnoreCase('(1:N)'))
		&& 
		(rightEnding.cardinality.equalsIgnoreCase('(0:N)') || rightEnding.cardinality.equalsIgnoreCase('(1:N)')))
		&& leftEnding.target instanceof Entity 
		&& rightEnding.target instanceof Entity] SEPARATOR " \n);\n" AFTER ");\n"»
«««		 Variável para fazer conversões de tipos (cast) dos targets da relação
		«var leftEnt = r.leftEnding.target as Entity»«var rightEnt = r.rightEnding.target as Entity»
		-- Table: «r.name.toUpperCase»
		-- DROP TABLE «r.name.toUpperCase»;	
		CREATE TABLE IF NOT EXISTS «r.name.toLowerCase» (
«««		aqui se escreve e se armazena o atributo chave primária especificado na relação caso exista
		«FOR a : r.attributes.filter[isIsKey]»	«pgsql_AttTypeChecker(a)»«{this.primaryKeys_NtoN.add(a.name.toString); null}»«ENDFOR»
«««		aqui se trata as relações que não são autorelacionamentos
		«IF !leftEnt.name.equalsIgnoreCase(rightEnt.name)»
			«IF leftEnt.is !== null»
«««			aqui a entidade da esquerda tem generalização
				«FOR a : leftEnt.is.attributes.filter[isIsKey]»
                 		«leftEnt.name.toLowerCase+"_"+pgsql_AttTypeChecker(a)»
                 	«{this.primaryKeys_NtoN.add(leftEnt.name.toLowerCase+"_"+a.name.toLowerCase); null}»
				«ENDFOR»
				«{this.sc_AlterTbl_NtoN.append(pgsql_AlterTable_NtoN_RefMapper(leftEnt, rightEnt, r, false, false, true, false, "[NtoN]")); null}»
			«ELSEIF leftEnt.is === null»
«««				aqui a entidade da esquerda NÃO tem generalização
				«FOR a : leftEnt.attributes.filter[isIsKey]»
                		«leftEnt.name.toLowerCase+"_"+pgsql_AttTypeChecker(a)»
                	«{this.primaryKeys_NtoN.add(leftEnt.name.toLowerCase+"_"+a.name.toLowerCase); null}»
				«ENDFOR»
				«{this.sc_AlterTbl_NtoN.append(pgsql_AlterTable_NtoN_RefMapper(leftEnt, rightEnt, r, false, false, false, true, "[NtoN]")); null}»
			«ENDIF»
«««				aqui a entidade da direita tem generalização
			«IF rightEnt.is !== null»
				«FOR a : rightEnt.is.attributes.filter[isIsKey]»
                		«rightEnt.name.toLowerCase+"_"+pgsql_AttTypeChecker(a)»
                	«{this.primaryKeys_NtoN.add(rightEnt.name.toLowerCase+"_"+a.name.toLowerCase); null}»
				«ENDFOR»
				«{this.sc_AlterTbl_NtoN.append(pgsql_AlterTable_NtoN_RefMapper(rightEnt, leftEnt, r, false, false, true, false, "[NtoN]")); null}»
«««				aqui a entidade da direita NÃO tem generalização
			«ELSEIF rightEnt.is === null»
				«FOR a : rightEnt.attributes.filter[isIsKey]»
						«rightEnt.name.toLowerCase+"_"+pgsql_AttTypeChecker(a)»
					«{this.primaryKeys_NtoN.add(rightEnt.name.toLowerCase+"_"+a.name.toLowerCase); null}»
				«ENDFOR»
				«{this.sc_AlterTbl_NtoN.append(pgsql_AlterTable_NtoN_RefMapper(rightEnt, leftEnt, r, false, false, false, true, "[NtoN]")); null}»
			«ENDIF»
«««			aqui se tratam os autorelacionamentos
		«ELSEIF leftEnt.name.equalsIgnoreCase(rightEnt.name)»
			«IF leftEnt.is !== null»
«««			aqui a entidade da esquerda tem generalização
				«FOR a : leftEnt.is.attributes.filter[isIsKey]»
                 		«leftEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_1"+pgsql_AttTypeChecker_Unnamed(a)»
                 	«{this.primaryKeys_NtoN.add(leftEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_1"); null}»
				«ENDFOR»
				«{this.sc_AlterTbl_NtoN.append(pgsql_AlterTable_NtoN_RefMapper(leftEnt, rightEnt, r, true, false, false, false, "[NtoN]")); null}»
«««				aqui a entidade da esquerda NÃO tem generalização
			«ELSEIF leftEnt.is === null»
				«FOR a : leftEnt.attributes.filter[isIsKey]»
                		«leftEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_1"+pgsql_AttTypeChecker_Unnamed(a)»
                	«{this.primaryKeys_NtoN.add(leftEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_1"); null}»
				«ENDFOR»
				«{this.sc_AlterTbl_NtoN.append(pgsql_AlterTable_NtoN_RefMapper(leftEnt, rightEnt, r, false, true, false, false, "[NtoN]")); null}»
			«ENDIF»
«««			aqui a entidade da direita tem generalização
			«IF rightEnt.is !== null»
				«FOR a : rightEnt.is.attributes.filter[isIsKey]»
                		«rightEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_2"+pgsql_AttTypeChecker_Unnamed(a)»
                	«{this.primaryKeys_NtoN.add(rightEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_2"); null}»
				«ENDFOR»
«««				aqui a entidade da direita NÃO tem generalização
			«ELSEIF rightEnt.is === null»
				«FOR a : rightEnt.attributes.filter[isIsKey]»
						«rightEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_2"+pgsql_AttTypeChecker_Unnamed(a)»
					«{this.primaryKeys_NtoN.add(rightEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_2"); null}»
				«ENDFOR»
			«ENDIF»
		«ENDIF»
«««		aqui se escreve os atributos do relacionamento caso existam
		«FOR a : r.attributes.filter[!isIsKey]»	«pgsql_AttTypeChecker(a)»«ENDFOR»
«««		«pgsql_MountPkList(this.primaryKeys, this.inheritedPrimaryKeys)»
			CONSTRAINT pk_«r.name.toLowerCase» PRIMARY KEY («FOR pk : primaryKeys_NtoN SEPARATOR ", "»«pk.toString»«ENDFOR»)
		«{this.primaryKeys_NtoN.clear; null}»
		«ENDFOR»
	'''
	
	def private pgsql_TernaryEntitiesMapper(ERModel model) '''	
		«FOR r : model.relations.filter[i|i.leftEnding.target instanceof Relation && i.rightEnding.target instanceof Entity]»
			«var auxRel = r.leftEnding.target as Relation»
			«var auxEnt = r.rightEnding.target as Entity»
			«var auxLeftEntity = auxRel.leftEnding.target as Entity»
			«var auxRightEntity = auxRel.rightEnding.target as Entity»
«««			-- CASO 1
«««			-- Relação: «r.name.toString.toUpperCase»
«««			-- Esquerda é relação: «auxRel.name.toUpperCase»
«««			-- Direita é entidade: «auxEnt.name.toUpperCase»		
			-- Table: «r.name.toUpperCase»
			-- DROP TABLE «r.name.toUpperCase»;	
			CREATE TABLE IF NOT EXISTS «r.name.toLowerCase» (
«««			Pega os atributos PK da entidade
			«FOR att : auxEnt.attributes.filter[isIsKey]»	«auxEnt.name.toLowerCase+"_"+pgsql_AttTypeChecker(att)»
			«ENDFOR»
			«FOR att : auxLeftEntity.attributes.filter[isIsKey]»	«auxLeftEntity.name.toLowerCase+"_"+pgsql_AttTypeChecker(att)»
			«ENDFOR»
			«FOR att : auxRightEntity.attributes.filter[isIsKey]»	«auxRightEntity.name.toLowerCase+"_"+pgsql_AttTypeChecker(att)»
			«ENDFOR»
«««			lista os atributos do relacionamento caso existam, se tiver alguma pk então adiciona no array de pks
			«IF r.attributes !== null»
				«FOR att : r.attributes»	«pgsql_AttTypeChecker(att)»«IF att.isIsKey»«{this.primaryKeys_Ternary.add(att.name.toLowerCase); null}»«ENDIF»
				«ENDFOR»
			«ENDIF»
«««			adiciona as PKS da entidade na lista de CONSTRAINT PK do Ternário			
			«{this.mapTernary.put(auxEnt.name, new ArrayList); null}»
			«FOR att : auxEnt.attributes.filter[isIsKey]»«{this.primaryKeys_Ternary.add(auxEnt.name.toLowerCase+"_"+att.name.toString); null}»
			«{this.mapTernary.get(auxEnt.name).add(att.name.toString.toLowerCase); null}»
			«ENDFOR»
«««			Lado ESQUERDO da relação N para N			
			«{this.mapTernary.put(auxLeftEntity.name, new ArrayList); null}»
			«FOR att : auxLeftEntity.attributes.filter[isIsKey]»«{this.primaryKeys_Ternary.add(auxLeftEntity.name.toLowerCase+"_"+att.name.toString.toLowerCase); null}»
			«{this.mapTernary.get(auxLeftEntity.name).add(auxLeftEntity.name.toLowerCase+"_"+att.name.toString.toLowerCase); null}»
			«ENDFOR»
«««			Lado DIREITO da relação N para N
			«{this.mapTernary.put(auxRightEntity.name, new ArrayList); null}»
			«FOR att : auxRightEntity.attributes.filter[isIsKey]»«{this.primaryKeys_Ternary.add(auxRightEntity.name.toLowerCase+"_"+att.name.toString.toLowerCase); null}»
			«{this.mapTernary.get(auxRightEntity.name).add(auxRightEntity.name.toLowerCase+"_"+att.name.toString.toLowerCase); null}»
			«ENDFOR»
«««				-- MAPA DO «auxEnt.name.toUpperCase»: «FOR element : mapTernary.get(auxEnt.name) SEPARATOR ", "»«element.toString»«ENDFOR»
«««				-- MAPA DO «auxLeftEntity.name.toUpperCase»: «FOR element : mapTernary.get(auxLeftEntity.name) SEPARATOR ", "»«element.toString»«ENDFOR»
«««				-- MAPA DO «auxRightEntity.name.toUpperCase»: «FOR element : mapTernary.get(auxRightEntity.name) SEPARATOR ", "»«element.toString»«ENDFOR»
				CONSTRAINT pk_«r.name.toLowerCase» PRIMARY KEY («FOR pk : primaryKeys_Ternary SEPARATOR ", "»«pk.toString»«ENDFOR») «{this.primaryKeys_Ternary.clear; null}»
				«{this.sc_AlterTbl_1toN.append(pgsql_AlterTable_Ternary_RefMapper(r.name, auxEnt.name, auxRel.name, auxLeftEntity.name, auxRightEntity.name, mapTernary)); null}»«{this.mapTernary.clear; null}»
			);
			
		«ENDFOR»
		«FOR r : model.relations.filter[i|i.leftEnding.target instanceof Entity && i.rightEnding.target instanceof Relation]»
			«var auxEnt = r.leftEnding.target as Entity»
			«var auxRel = r.rightEnding.target as Relation»
			«var auxLeftEntity = auxRel.leftEnding.target as Entity»
			«var auxRightEntity = auxRel.rightEnding.target as Entity»
«««			-- CASO 2 
«««			-- Relação: «r.name.toString.toUpperCase»
«««			-- Esquerda é entidade: «auxRel.name.toUpperCase»
«««			-- Direita é relação: «auxEnt.name.toUpperCase»
			-- Table: «r.name.toUpperCase»
			-- DROP TABLE «r.name.toUpperCase»;	
			CREATE TABLE IF NOT EXISTS «r.name.toLowerCase» (
«««			Pega os atributos PK da entidade
			«FOR att : auxEnt.attributes.filter[isIsKey]»	«auxEnt.name.toLowerCase+"_"+pgsql_AttTypeChecker(att)»
			«ENDFOR»
			«FOR att : auxLeftEntity.attributes.filter[isIsKey]»	«auxLeftEntity.name.toLowerCase+"_"+pgsql_AttTypeChecker(att)»
			«ENDFOR»
			«FOR att : auxRightEntity.attributes.filter[isIsKey]»	«auxRightEntity.name.toLowerCase+"_"+pgsql_AttTypeChecker(att)»
			«ENDFOR»
«««			lista os atributos do relacionamento caso existam, se tiver alguma pk então adiciona no array de pks
			«IF r.attributes !== null»
				«FOR att : r.attributes»	«pgsql_AttTypeChecker(att)»«IF att.isIsKey»«{this.primaryKeys_Ternary.add(att.name.toLowerCase); null}»«ENDIF»
				«ENDFOR»
			«ENDIF»
«««			adiciona as PKS da entidade na lista de CONSTRAINT PK do Ternário			
			«{this.mapTernary.put(auxEnt.name, new ArrayList); null}»
			«FOR att : auxEnt.attributes.filter[isIsKey]»«{this.primaryKeys_Ternary.add(auxEnt.name.toLowerCase+"_"+att.name.toString); null}»
			«{this.mapTernary.get(auxEnt.name).add(att.name.toString.toLowerCase); null}»
			«ENDFOR»
«««			Lado ESQUERDO da relação N para N			
			«{this.mapTernary.put(auxLeftEntity.name, new ArrayList); null}»
			«FOR att : auxLeftEntity.attributes.filter[isIsKey]»«{this.primaryKeys_Ternary.add(auxLeftEntity.name.toLowerCase+"_"+att.name.toString.toLowerCase); null}»
			«{this.mapTernary.get(auxLeftEntity.name).add(auxLeftEntity.name.toLowerCase+"_"+att.name.toString.toLowerCase); null}»
			«ENDFOR»
«««			Lado DIREITO da relação N para N
			«{this.mapTernary.put(auxRightEntity.name, new ArrayList); null}»
			«FOR att : auxRightEntity.attributes.filter[isIsKey]»«{this.primaryKeys_Ternary.add(auxRightEntity.name.toLowerCase+"_"+att.name.toString.toLowerCase); null}»
			«{this.mapTernary.get(auxRightEntity.name).add(auxRightEntity.name.toLowerCase+"_"+att.name.toString.toLowerCase); null}»
			«ENDFOR»
«««				-- MAPA DO «auxEnt.name.toUpperCase»: «FOR element : mapTernary.get(auxEnt.name) SEPARATOR ", "»«element.toString»«ENDFOR»
«««				-- MAPA DO «auxLeftEntity.name.toUpperCase»: «FOR element : mapTernary.get(auxLeftEntity.name) SEPARATOR ", "»«element.toString»«ENDFOR»
«««				-- MAPA DO «auxRightEntity.name.toUpperCase»: «FOR element : mapTernary.get(auxRightEntity.name) SEPARATOR ", "»«element.toString»«ENDFOR»
				CONSTRAINT pk_«r.name.toLowerCase» PRIMARY KEY («FOR pk : primaryKeys_Ternary SEPARATOR ", "»«pk.toString»«ENDFOR») «{this.primaryKeys_Ternary.clear; null}»
				«{this.sc_AlterTbl_1toN.append(pgsql_AlterTable_Ternary_RefMapper(r.name, auxEnt.name, auxRel.name, auxLeftEntity.name, auxRightEntity.name, mapTernary)); null}»«{this.mapTernary.clear; null}»
			);
		«ENDFOR»
	'''
	
	def private pgsql_GeneralizationRefMapper(ERModel m) '''
		«FOR e : m.entities.filter[is !== null]»
			-- GENERALIZATION
			ALTER TABLE ONLY public.«e.name.toLowerCase» ADD CONSTRAINT fk_gen_«e.name.toLowerCase+"_"+e.is.toString.toLowerCase» FOREIGN KEY («FOR a : e.is.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toString»«ENDFOR») REFERENCES public.«e.is.toString.toLowerCase» («FOR a : e.is.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toString»«ENDFOR»);
		«ENDFOR»
	'''	
	
	def private pgsql_AlterTable_1to1_1toN_RefMapper(Entity alterTbl, Entity refTbl, Relation r, Boolean selfRelWithGen, Boolean selfRelNoGen, Boolean relWithOneGen, Boolean relNoGen, String cardinalityRel) '''			
			«IF selfRelWithGen»
			-- «cardinalityRel»: Self-relation WITH generalization
			ALTER TABLE ONLY public.«alterTbl.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase» FOREIGN KEY («FOR a : refTbl.attributes.filter[isIsKey] SEPARATOR ", "»«r.name.toLowerCase+"_"+a.name.toLowerCase»«ENDFOR») REFERENCES public.«alterTbl.name.toLowerCase» («FOR a : refTbl.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			«ELSEIF selfRelNoGen»
			-- «cardinalityRel»: Self-relation WITHOUT generalization
			ALTER TABLE ONLY public.«alterTbl.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase» FOREIGN KEY («FOR a : alterTbl.attributes.filter[isIsKey] SEPARATOR ", "»«r.name.toLowerCase+"_"+a.name.toLowerCase»«ENDFOR») REFERENCES public.«refTbl.name.toLowerCase» («FOR a : alterTbl.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			«ELSEIF relWithOneGen»
			-- «cardinalityRel»: Relationship with ONE ENTITY that HAS GENERALIZATION
			ALTER TABLE ONLY public.«alterTbl.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase» FOREIGN KEY («FOR a : refTbl.is.attributes.filter[isIsKey] SEPARATOR ", "»«r.name.toLowerCase+"_"+a.name.toLowerCase»«ENDFOR») REFERENCES public.«refTbl.name.toLowerCase» («FOR a : refTbl.is.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			«ELSEIF relNoGen»
			-- «cardinalityRel»: Relationship in which BOTH ENTITIES have NO GENERALIZATION
			ALTER TABLE ONLY public.«alterTbl.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase» FOREIGN KEY («FOR a : refTbl.attributes.filter[isIsKey] SEPARATOR ", "»«r.name.toLowerCase+"_"+a.name.toLowerCase»«ENDFOR») REFERENCES public.«refTbl.name.toLowerCase» («FOR a : refTbl.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			«ENDIF»
	'''

	def private pgsql_AlterTable_NtoN_RefMapper(Entity leftEnt, Entity rightEnt, Relation r, Boolean selfRelWithGen, Boolean selfRelNoGen, Boolean relWithOneGen, Boolean relNoGen, String cardinalityRel) '''			
			«IF selfRelWithGen»
			-- «cardinalityRel»: Self-relation WITH generalization
			ALTER TABLE ONLY public.«r.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase+"_"+leftEnt.name.toLowerCase»_1 FOREIGN KEY («FOR a : leftEnt.is.attributes.filter[isIsKey] SEPARATOR ", "»«leftEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_1"»«ENDFOR») REFERENCES public.«leftEnt.name.toLowerCase» («FOR a : leftEnt.is.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			ALTER TABLE ONLY public.«r.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase+"_"+rightEnt.name.toLowerCase»_2 FOREIGN KEY («FOR a : rightEnt.is.attributes.filter[isIsKey] SEPARATOR ", "»«rightEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_2"»«ENDFOR») REFERENCES public.«rightEnt.name.toLowerCase» («FOR a : rightEnt.is.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			«ELSEIF selfRelNoGen»
			-- «cardinalityRel»: Self-relation WITHOUT generalization
			ALTER TABLE ONLY public.«r.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase+"_"+leftEnt.name.toLowerCase»_1 FOREIGN KEY («FOR a : leftEnt.attributes.filter[isIsKey] SEPARATOR ", "»«leftEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_1"»«ENDFOR») REFERENCES public.«leftEnt.name.toLowerCase» («FOR a : leftEnt.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			ALTER TABLE ONLY public.«r.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase+"_"+rightEnt.name.toLowerCase»_2 FOREIGN KEY («FOR a : rightEnt.attributes.filter[isIsKey] SEPARATOR ", "»«rightEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_2"»«ENDFOR») REFERENCES public.«rightEnt.name.toLowerCase» («FOR a : rightEnt.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			«ELSEIF relWithOneGen»
			-- «cardinalityRel»: Relationship with ONE ENTITY that HAS GENERALIZATION
			ALTER TABLE ONLY public.«r.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase+"_"+leftEnt.name.toLowerCase» FOREIGN KEY («FOR a : leftEnt.is.attributes.filter[isIsKey] SEPARATOR ", "»«leftEnt.name.toLowerCase+"_"+a.name.toLowerCase»«ENDFOR») REFERENCES public.«leftEnt.name.toLowerCase» («FOR a : leftEnt.is.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			«ELSEIF relNoGen»
			-- «cardinalityRel»: Relationship in which BOTH ENTITIES have NO GENERALIZATION
			ALTER TABLE ONLY public.«r.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase+"_"+leftEnt.name.toLowerCase» FOREIGN KEY («FOR a : leftEnt.attributes.filter[isIsKey] SEPARATOR ", "»«leftEnt.name.toLowerCase+"_"+a.name.toLowerCase»«ENDFOR») REFERENCES public.«leftEnt.name.toLowerCase» («FOR a : leftEnt.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			«ENDIF»
	'''
	
	def private pgsql_AlterTable_Ternary_RefMapper(String tabelaTernaria, String tabelaEntidade, String nomeRelacaoNN, String leftNN, String rightNN, HashMap keysMap) '''			
«««			MAPA DO «tabelaEntidade.toUpperCase»: «FOR e : mapTernary.get(tabelaEntidade) SEPARATOR ", "»«e.toString»«ENDFOR»
«««			MAPA DO «leftNN.toUpperCase»: «FOR e : mapTernary.get(leftNN) SEPARATOR ", "»«e.toString»«ENDFOR»
«««			MAPA DO «rightNN.toUpperCase»: «FOR e : mapTernary.get(rightNN) SEPARATOR ", "»«e.toString»«ENDFOR»
			-- [Ternary Relationship]
			ALTER TABLE ONLY public.«tabelaTernaria» ADD CONSTRAINT fk_«tabelaTernaria+"_"+tabelaEntidade.toLowerCase» FOREIGN KEY («FOR e : this.mapTernary.get(tabelaEntidade) SEPARATOR ", "»«tabelaEntidade.toString.toLowerCase+"_"+e.toString»«ENDFOR») REFERENCES public.«tabelaEntidade» («FOR e : this.mapTernary.get(tabelaEntidade) SEPARATOR ", "»«e.toString»«ENDFOR»);
			ALTER TABLE ONLY public.«tabelaTernaria» ADD CONSTRAINT fk_«tabelaTernaria+"_"+nomeRelacaoNN.toLowerCase» FOREIGN KEY («FOR e : this.mapTernary.get(leftNN) SEPARATOR ", "»«e.toString»«ENDFOR», «FOR e : this.mapTernary.get(rightNN) SEPARATOR ", "»«e.toString»«ENDFOR») REFERENCES public.«nomeRelacaoNN» («FOR e : this.mapTernary.get(leftNN) SEPARATOR ", "»«e.toString»«ENDFOR», «FOR e : this.mapTernary.get(rightNN) SEPARATOR ", "»«e.toString»«ENDFOR»);
	'''
}



