package org.xtext.unipampa.erdsl.generator

import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.unipampa.erdsl.erDsl.ERModel
import org.xtext.unipampa.erdsl.erDsl.Entity
import org.xtext.unipampa.erdsl.erDsl.Relation
import org.xtext.unipampa.erdsl.erDsl.Attribute
import java.util.ArrayList


/**
* 
* This class serves as a template for the automated generation of a 
* physical schema (<b>MySQL</b>) which is saved as a <b>.sql</b> file in the 
* <b>src-gen</b> folder within the ERtext project.
*
* @author Unipampa/LESSE </br> - Jonnathan Riquelmo: Initial contribution.
* @version 0.1
* @since   0.1 (2019/2)
*/	
class MysqlFileGenerator extends AbstractGenerator {
	
	var pkList = new ArrayList<String>()
	var primaryKeys = new ArrayList<Entity>()
	var inheritedPrimaryKeys = new ArrayList<Entity>()
	var primaryKeys_NtoN = new ArrayList
	
	var StringBuilder sc_AlterTbl_1to1 = new StringBuilder
	var StringBuilder sc_AlterTbl_1toN = new StringBuilder
	var StringBuilder sc_AlterTbl_NtoN = new StringBuilder
	var StringBuilder sc_AlterTbl_Ternary = new StringBuilder	
		
	override doGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) {

		val modeloER = input.contents.get(0) as ERModel

		try {
			fsa.generateFile('MySQL_DDL.sql', mysql_CreateModel(modeloER))
		} catch (Exception e) {
			println(e.stackTrace.toString)
		}		
	}
	
	def private mysql_CreateModel(ERModel modeloER) '''		
	-- ####################################################
	-- #					MySQL Template 			  	  #
	-- ####################################################
	-- #				Generated by ERtext 			  #
	-- ####################################################
	
	«mysql_DomainMapper(modeloER)»
		
	«mysql_SimpleEntitiesMapper(modeloER)»
	
	«mysql_NToN_DerivedEntitiesMapper(modeloER)»
	
	«mysql_TernaryEntitiesMapper(modeloER)»
	
	«mysql_GeneralizationRefMapper(modeloER)»
	«sc_AlterTbl_1to1.toString»
	«sc_AlterTbl_1to1.length = 0»
	«sc_AlterTbl_1toN.toString»
	«sc_AlterTbl_1toN.length = 0»
	«sc_AlterTbl_NtoN.toString»
	«sc_AlterTbl_NtoN.length = 0»
	«sc_AlterTbl_Ternary.toString»
	«sc_AlterTbl_Ternary.length = 0»
	'''
	
	def private mysql_DomainMapper (ERModel m) '''
	-- Database: «m.domain.name.toString.toUpperCase»
	-- DROP DATABASE «m.domain.name.toString.toUpperCase»;
	-- CREATE DATABASE IF NOT EXISTS «m.domain.name.toString.toUpperCase»»
	
	--DROP TABLE IF EXISTS 
	-- «FOR e : m.entities SEPARATOR ", "»public."«e.name.toLowerCase»"«ENDFOR»«FOR r : m.relations.filter[((leftEnding.cardinality.equalsIgnoreCase('(0:N)') || leftEnding.cardinality.equalsIgnoreCase('(1:N)')) && (rightEnding.cardinality.equalsIgnoreCase('(0:N)') || rightEnding.cardinality.equalsIgnoreCase('(1:N)')))] BEFORE ", " SEPARATOR ", "»public."«r.name.toLowerCase»"«ENDFOR» 
	-- CASCADE;
	'''
	
	def private mysql_SimpleEntitiesMapper(ERModel m) '''
		«FOR entity : m.entities SEPARATOR " \n);\n" AFTER ");\n"»
			-- Table: «entity.name.toUpperCase»
			«IF !entity.generalization.isNullOrEmpty»
			-- Generalization/Specialization «entity.generalization.toString.toUpperCase» from table «entity.is.toString.toUpperCase»«ENDIF»
			-- DROP TABLE «entity.name.toUpperCase»;	
			CREATE TABLE IF NOT EXISTS «entity.name.toLowerCase» (
				«mysql_AttributesMapper(m, entity)»
		«ENDFOR»
	'''
		
	def private mysql_AttributesMapper (ERModel m, Entity e) '''
	«IF e.is !== null»
«««	Check for inheritance and write the inherited key attribute
		«FOR PKInherited : e.is.attributes.filter[isIsKey]»
			«mysql_AttTypeChecker(PKInherited)»
		«ENDFOR»
		«{this.inheritedPrimaryKeys.add(e.is); null}»
	«ENDIF»
«««	Check if it has its own key attribute and write
	«FOR a : e.attributes.filter[isIsKey]»
		«mysql_AttTypeChecker(a)»
	«ENDFOR»		
	«{this.primaryKeys.add(e); null}»
«««	Check other descriptive attributes and write
	«FOR a : e.attributes.filter[!isIsKey]»
		«mysql_AttTypeChecker(a)»
	«ENDFOR»
	«mysql_1To1_RefCheck(m, e)»
	«mysql_1ToN_RefCheck(m, e)»
«««	Produces a list of pks with own pks, and found inherited pks.
	«mysql_MountPkList(primaryKeys, inheritedPrimaryKeys)»
«««	Writes the complete list of pks and then clears the arrays so the same process can be done for other entities without residual traces.
	CONSTRAINT pk_«e.name.toLowerCase» PRIMARY KEY («FOR pks : pkList SEPARATOR ", "»«pks.toLowerCase»«ENDFOR»)
	«{this.primaryKeys.clear; null}»
	«{this.inheritedPrimaryKeys.clear; null}»
	«{this.pkList.clear; null}»
	'''
	
	private def mysql_MountPkList(ArrayList<Entity> pks, ArrayList<Entity> inheritedPks){
		if (!inheritedPks.isEmpty) {
			for (e : inheritedPks) {
				for (a : e.attributes.filter[isIsKey]) {
					this.pkList.add(a.name.toLowerCase)
				}
			}
		}
		if (!pks.isEmpty) {
			for (e : pks) {
				for (a : e.attributes.filter[isIsKey]) {
					this.pkList.add(a.name.toLowerCase)
				}
			}
		}
	}
	
	
	private def mysql_AttTypeChecker(Attribute a) '''
		«IF a.type.toString.equalsIgnoreCase("string")»«a.name.toLowerCase» VARCHAR (255) NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("int")»«a.name.toLowerCase» INTEGER NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("datetime")»«a.name.toLowerCase» DATE NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("money")»«a.name.toLowerCase» NUMERIC NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("double")»«a.name.toLowerCase» FLOAT NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("boolean")»«a.name.toLowerCase» BIT NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("file")»«a.name.toLowerCase» BLOB NOT NULL,
		«ENDIF»
	'''
	
	private def mysql_AttTypeChecker_Unnamed(Attribute a) '''
		«IF a.type.toString.equalsIgnoreCase("string")» VARCHAR (255) NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("int")» INTEGER NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("datetime")» DATE NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("money")» NUMERIC NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("double")» FLOAT NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("boolean")» BIT NOT NULL,
		«ELSEIF a.type.toString.equalsIgnoreCase("file")» BLOB NOT NULL,
		«ENDIF»
	'''

	def private mysql_1To1_RefCheck(ERModel m, Entity e) '''
		«FOR r : m.relations»
			«IF ((r.leftEnding.cardinality.equalsIgnoreCase('(0:1)') || r.leftEnding.cardinality.equalsIgnoreCase('(1:1)'))
			&& 
			(r.rightEnding.cardinality.equalsIgnoreCase('(0:1)') || r.rightEnding.cardinality.equalsIgnoreCase('(1:1)'))) 
			&& r.leftEnding.target instanceof Entity
			&& r.rightEnding.target instanceof Entity»
				«IF r.rightEnding.target.toString.equalsIgnoreCase(e.name)»
«««					Relação: «r.name» | Entidade: «e.name»
					«FOR eAux : m.entities»
						«IF r.leftEnding.target.toString.equalsIgnoreCase(eAux.name)»
«««						Here, the treatment of the first case of relation 1_1 takes place, where the recursive/reflexive relationships are identified.
							«IF e.name.equalsIgnoreCase(eAux.name)»
«««								É AUTORELACIONAMENTO COM «eAux.name»
«««								Being recursive/reflexive relationship, it checks if the entity inherits pks, if true, it looks for the pks of the superclass, adding the name of the relation as a prefix.
								«IF e.is !== null»
									«FOR a : e.is.attributes.filter[isIsKey]»
										«r.name.toLowerCase+"_"+mysql_AttTypeChecker(a)»
									«ENDFOR»
									«{this.sc_AlterTbl_1to1.append(mysql_AlterTable_1to1_1toN_RefMapper(e, e.is, r, true, false, false, false, "[1to1]")); null}»
«««									If it is not recursive/reflexive relationship with an entity that inherits pks, it looks for the pks of the recursive/reflexive relationship entity itself, adding the name of the relation as a prefix.
								«ELSEIF e.is === null»
									«FOR a : e.attributes.filter[isIsKey]»
										«r.name.toLowerCase+"_"+mysql_AttTypeChecker(a)»
									«ENDFOR»
									«{this.sc_AlterTbl_1to1.append(mysql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, true, false, false, "[1to1]")); null}»
								«ENDIF»
«««								Here happens the treatment of the second case of relation 1_1 when they are not recursive/reflexive relationships.
							«ELSEIF !e.name.equalsIgnoreCase(eAux.name)»
«««								NÃO É AUTORELACIONAMENTO COM «eAux.name»
«««								If the entity being related has inheritance from another, the inherited pks are searched, adding the name of the relation as a prefix.
								«IF eAux.is !== null»
									«FOR a : eAux.is.attributes.filter[isIsKey]»
										«r.name.toLowerCase+"_"+mysql_AttTypeChecker(a)»
									«ENDFOR»
									«{this.sc_AlterTbl_1to1.append(mysql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, false, true, false, "[1to1]")); null}»
«««								If the entity being related does not have inheritance, its own pks are searched, adding the name of the relation as a prefix.
								«ELSEIF eAux.is === null»
									«FOR a : eAux.attributes.filter[isIsKey]»
										«r.name.toLowerCase+"_"+mysql_AttTypeChecker(a)»
									«ENDFOR»
									«{this.sc_AlterTbl_1to1.append(mysql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, false, false, true, "[1to1]")); null}»
								«ENDIF»
							«ENDIF»
						«ENDIF»
					«ENDFOR»
				«ENDIF» 
			«ENDIF»
		«ENDFOR»
	'''
	
	
	def private mysql_1ToN_RefCheck(ERModel m, Entity e) '''
		«FOR r : m.relations.filter[((leftEnding.cardinality.equalsIgnoreCase('(0:1)') || leftEnding.cardinality.equalsIgnoreCase('(1:1)'))
				&& 
				(rightEnding.cardinality.equalsIgnoreCase('(0:N)') || rightEnding.cardinality.equalsIgnoreCase('(1:N)'))) 
				&& leftEnding.target instanceof Entity
				&& rightEnding.target instanceof Entity]»
					«IF r.rightEnding.target.toString.equalsIgnoreCase(e.name)»	
«««						Relação: «r.name» | Entidade: «e.name»
						«FOR eAux : m.entities»
							«IF r.leftEnding.target.toString.equalsIgnoreCase(eAux.name)»
«««							Here, the treatment of the first case of relation 1_N takes place, where the recursive/reflexive relationships are identified.
								«IF e.name.equalsIgnoreCase(eAux.name)»
«««									É AUTORELACIONAMENTO COM «eAux.name»
«««									Being recursive/reflexive relationship, it checks if the entity inherits pks, if true, it looks for the pks of the superclass, adding the name of the relation as a prefix.
									«IF e.is !== null»
										«FOR a : e.is.attributes.filter[isIsKey]»
											«r.name.toLowerCase+"_"+mysql_AttTypeChecker(a)»
										«ENDFOR»
										«{this.sc_AlterTbl_1toN.append(mysql_AlterTable_1to1_1toN_RefMapper(e, e.is, r, true, false, false, false, "[1toN]")); null}»
«««										If it is not recursive/reflexive relationship with an entity that inherits pks, it looks for the pks of the recursive/reflexive relationship entity itself, adding the name of the relation as a prefix.
									«ELSEIF e.is === null»
										«FOR a : e.attributes.filter[isIsKey]»
											«r.name.toLowerCase+"_"+mysql_AttTypeChecker(a)»
										«ENDFOR»
										«{this.sc_AlterTbl_1toN.append(mysql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, true, false, false, "[1toN]")); null}»
									«ENDIF»
«««									Here happens the treatment of the second case of relation 1_N when they are not recursive/reflexive relationships.
								«ELSEIF !e.name.equalsIgnoreCase(eAux.name)»
«««									NÃO É AUTORELACIONAMENTO COM «eAux.name»
«««									If the entity being related has inheritance from another, the inherited pks are searched, adding the name of the relation as a prefix.
									«IF eAux.is !== null»
										«FOR a : eAux.is.attributes.filter[isIsKey]»
											«r.name.toLowerCase+"_"+mysql_AttTypeChecker(a)»
										«ENDFOR»
										«{this.sc_AlterTbl_1toN.append(mysql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, false, true, false, "[1toN]")); null}»
«««									If the entity being related does not have inheritance, its own pks are searched, adding the name of the relation as a prefix.
									«ELSEIF eAux.is === null»
										«FOR a : eAux.attributes.filter[isIsKey]»
                                        	«r.name.toLowerCase+"_"+mysql_AttTypeChecker(a)»
										«ENDFOR»
									«{this.sc_AlterTbl_1toN.append(mysql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, false, false, true, "[1toN]")); null}»
									«ENDIF»
								«ENDIF»
							«ENDIF»
						«ENDFOR»					
					«ENDIF»
			«ENDFOR»
			«FOR r : m.relations.filter[(((leftEnding.cardinality.equalsIgnoreCase('(0:N)') || leftEnding.cardinality.equalsIgnoreCase('(1:N)'))
				&& 
				(rightEnding.cardinality.equalsIgnoreCase('(0:1)') || rightEnding.cardinality.equalsIgnoreCase('(1:1)'))))
				&& leftEnding.target instanceof Entity 
				&& rightEnding.target instanceof Entity]»
					«IF r.leftEnding.target.toString.equalsIgnoreCase(e.name)»
«««						Relação: «r.name» | Entidade: «e.name»
						«FOR eAux : m.entities»
							«IF r.rightEnding.target.toString.equalsIgnoreCase(eAux.name)»
«««							Here, the treatment of the first case of relation N_1 takes place, where the recursive/reflexive relationships are identified.
								«IF e.name.equalsIgnoreCase(eAux.name)»
«««									É AUTORELACIONAMENTO COM «eAux.name»
«««									Being recursive/reflexive relationship, it checks if the entity inherits pks, if true, it looks for the pks of the superclass, adding the name of the relation as a prefix.
									«IF e.is !== null»
										«FOR a : e.is.attributes.filter[isIsKey]»
                                         	«r.name.toLowerCase+"_"+mysql_AttTypeChecker(a)»
										«ENDFOR»
										«{this.sc_AlterTbl_1toN.append(mysql_AlterTable_1to1_1toN_RefMapper(e, e.is, r, true, false, false, false, "[Nto1]")); null}»
«««										If it is not recursive/reflexive relationship with an entity that inherits pks, it looks for the pks of the recursive/reflexive relationship entity itself, adding the name of the relation as a prefix.
									«ELSEIF e.is === null»
										«FOR a : e.attributes.filter[isIsKey]»
                                        	«r.name.toLowerCase+"_"+mysql_AttTypeChecker(a)»
										«ENDFOR»
										«{this.sc_AlterTbl_1toN.append(mysql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, true, false, false, "[Nto1]")); null}»
									«ENDIF»
«««									Here happens the treatment of the second case of relation N_1 when they are not recursive/reflexive relationships.
								«ELSEIF !e.name.equalsIgnoreCase(eAux.name)»
«««									NÃO É AUTORELACIONAMENTO COM «eAux.name»
«««									If the entity being related has inheritance from another, the inherited pks are searched, adding the name of the relation as a prefix.
									«IF eAux.is !== null»
										«FOR a : eAux.is.attributes.filter[isIsKey]»
                                        	«r.name.toLowerCase+"_"+mysql_AttTypeChecker(a)»
										«ENDFOR»
										«{this.sc_AlterTbl_1toN.append(mysql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, false, true, false, "[Nto1]")); null}»
«««									If the entity being related does not have inheritance, its own pks are searched, adding the name of the relation as a prefix.
									«ELSEIF eAux.is === null»
										«FOR a : eAux.attributes.filter[isIsKey]»
                                        	«r.name.toLowerCase+"_"+mysql_AttTypeChecker(a)»
										«ENDFOR»
										«{this.sc_AlterTbl_1toN.append(mysql_AlterTable_1to1_1toN_RefMapper(e, eAux, r, false, false, false, true, "[Nto1]")); null}»
									«ENDIF»
								«ENDIF»
							«ENDIF»
						«ENDFOR»					
					«ENDIF»
		«ENDFOR»
	'''
	
	//	TODO: Comentar este método por inteiro como os anteriores
	def private mysql_NToN_DerivedEntitiesMapper(ERModel m)'''
		«FOR r : m.relations.filter[((leftEnding.cardinality.equalsIgnoreCase('(0:N)') || leftEnding.cardinality.equalsIgnoreCase('(1:N)'))
		&& 
		(rightEnding.cardinality.equalsIgnoreCase('(0:N)') || rightEnding.cardinality.equalsIgnoreCase('(1:N)')))
		&& leftEnding.target instanceof Entity 
		&& rightEnding.target instanceof Entity] SEPARATOR " \n);\n" AFTER ");\n"»
«««		 Variável para fazer conversões de tipos (cast) dos targets da relação
		«var leftEnt = r.leftEnding.target as Entity»«var rightEnt = r.rightEnding.target as Entity»
		-- Table: «r.name.toUpperCase»
		-- DROP TABLE «r.name.toUpperCase»;	
		CREATE TABLE IF NOT EXISTS «r.name.toLowerCase» (
«««		aqui se escreve e se armazena o atributo chave primária especificado na relação caso exista
		«FOR a : r.attributes.filter[isIsKey]»	«mysql_AttTypeChecker(a)»«{this.primaryKeys_NtoN.add(a.name.toString); null}»«ENDFOR»
«««		aqui se trata as relações que não são autorelacionamentos
		«IF !leftEnt.name.equalsIgnoreCase(rightEnt.name)»
			«IF leftEnt.is !== null»
«««			aqui a entidade da esquerda tem generalização
				«FOR a : leftEnt.is.attributes.filter[isIsKey]»
                 		«leftEnt.name.toLowerCase+"_"+mysql_AttTypeChecker(a)»
                 	«{this.primaryKeys_NtoN.add(leftEnt.name.toLowerCase+"_"+a.name.toLowerCase); null}»
				«ENDFOR»
				«{this.sc_AlterTbl_NtoN.append(mysql_AlterTable_NtoN_RefMapper(leftEnt, rightEnt, r, false, false, true, false, "[NtoN]")); null}»
			«ELSEIF leftEnt.is === null»
«««				aqui a entidade da esquerda NÃO tem generalização
				«FOR a : leftEnt.attributes.filter[isIsKey]»
                		«leftEnt.name.toLowerCase+"_"+mysql_AttTypeChecker(a)»
                	«{this.primaryKeys_NtoN.add(leftEnt.name.toLowerCase+"_"+a.name.toLowerCase); null}»
				«ENDFOR»
				«{this.sc_AlterTbl_NtoN.append(mysql_AlterTable_NtoN_RefMapper(leftEnt, rightEnt, r, false, false, false, true, "[NtoN]")); null}»
			«ENDIF»
«««				aqui a entidade da direita tem generalização
			«IF rightEnt.is !== null»
				«FOR a : rightEnt.is.attributes.filter[isIsKey]»
                		«rightEnt.name.toLowerCase+"_"+mysql_AttTypeChecker(a)»
                	«{this.primaryKeys_NtoN.add(rightEnt.name.toLowerCase+"_"+a.name.toLowerCase); null}»
				«ENDFOR»
				«{this.sc_AlterTbl_NtoN.append(mysql_AlterTable_NtoN_RefMapper(rightEnt, leftEnt, r, false, false, true, false, "[NtoN]")); null}»
«««				aqui a entidade da direita NÃO tem generalização
			«ELSEIF rightEnt.is === null»
				«FOR a : rightEnt.attributes.filter[isIsKey]»
						«rightEnt.name.toLowerCase+"_"+mysql_AttTypeChecker(a)»
					«{this.primaryKeys_NtoN.add(rightEnt.name.toLowerCase+"_"+a.name.toLowerCase); null}»
				«ENDFOR»
				«{this.sc_AlterTbl_NtoN.append(mysql_AlterTable_NtoN_RefMapper(rightEnt, leftEnt, r, false, false, false, true, "[NtoN]")); null}»
			«ENDIF»
«««			aqui se tratam os autorelacionamentos
		«ELSEIF leftEnt.name.equalsIgnoreCase(rightEnt.name)»
			«IF leftEnt.is !== null»
«««			aqui a entidade da esquerda tem generalização
				«FOR a : leftEnt.is.attributes.filter[isIsKey]»
                 		«leftEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_1"+mysql_AttTypeChecker_Unnamed(a)»
                 	«{this.primaryKeys_NtoN.add(leftEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_1"); null}»
				«ENDFOR»
				«{this.sc_AlterTbl_NtoN.append(mysql_AlterTable_NtoN_RefMapper(leftEnt, rightEnt, r, true, false, false, false, "[NtoN]")); null}»
«««				aqui a entidade da esquerda NÃO tem generalização
			«ELSEIF leftEnt.is === null»
				«FOR a : leftEnt.attributes.filter[isIsKey]»
                		«leftEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_1"+mysql_AttTypeChecker_Unnamed(a)»
                	«{this.primaryKeys_NtoN.add(leftEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_1"); null}»
				«ENDFOR»
				«{this.sc_AlterTbl_NtoN.append(mysql_AlterTable_NtoN_RefMapper(leftEnt, rightEnt, r, false, true, false, false, "[NtoN]")); null}»
			«ENDIF»
«««			aqui a entidade da direita tem generalização
			«IF rightEnt.is !== null»
				«FOR a : rightEnt.is.attributes.filter[isIsKey]»
                		«rightEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_2"+mysql_AttTypeChecker_Unnamed(a)»
                	«{this.primaryKeys_NtoN.add(rightEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_2"); null}»
				«ENDFOR»
«««				aqui a entidade da direita NÃO tem generalização
			«ELSEIF rightEnt.is === null»
				«FOR a : rightEnt.attributes.filter[isIsKey]»
						«rightEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_2"+mysql_AttTypeChecker_Unnamed(a)»
					«{this.primaryKeys_NtoN.add(rightEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_2"); null}»
				«ENDFOR»
			«ENDIF»
		«ENDIF»
«««		aqui se escreve os atributos do relacionamento caso existam
		«FOR a : r.attributes.filter[!isIsKey]»	«mysql_AttTypeChecker(a)»«ENDFOR»
«««		«mysql_MountPkList(this.primaryKeys, this.inheritedPrimaryKeys)»
			CONSTRAINT pk_«r.name.toLowerCase» PRIMARY KEY («FOR pk : primaryKeys_NtoN SEPARATOR ", "»«pk.toString»«ENDFOR»)
		«{this.primaryKeys_NtoN.clear; null}»
		«ENDFOR»
	'''
	
	def private mysql_TernaryEntitiesMapper(ERModel model) '''	
		-- #######################################################
		-- #TODO: auto-generated method stub for Ternary Entities#
		-- #######################################################
	'''
	
	def private mysql_GeneralizationRefMapper(ERModel m) '''

		«FOR e : m.entities.filter[is !== null]»
			-- GENERALIZATION
			ALTER TABLE ONLY public.«e.name.toLowerCase» ADD CONSTRAINT fk_gen_«e.name.toLowerCase+"_"+e.is.toString.toLowerCase» FOREIGN KEY («FOR a : e.is.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toString»«ENDFOR») REFERENCES public.«e.is.toString.toLowerCase» («FOR a : e.is.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toString»«ENDFOR»);
		
		«ENDFOR»
	'''	
	
	def private mysql_AlterTable_1to1_1toN_RefMapper(Entity alterTbl, Entity refTbl, Relation r, Boolean selfRelWithGen, Boolean selfRelNoGen, Boolean relWithOneGen, Boolean relNoGen, String cardinalityRel) '''			
			«IF selfRelWithGen»
			-- «cardinalityRel»: Self-relation WITH generalization
			ALTER TABLE ONLY public.«alterTbl.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase» FOREIGN KEY («FOR a : refTbl.attributes.filter[isIsKey] SEPARATOR ", "»«r.name.toLowerCase+"_"+a.name.toLowerCase»«ENDFOR») REFERENCES public.«alterTbl.name.toLowerCase» («FOR a : refTbl.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			«ELSEIF selfRelNoGen»
			-- «cardinalityRel»: Self-relation WITHOUT generalization
			ALTER TABLE ONLY public.«alterTbl.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase» FOREIGN KEY («FOR a : alterTbl.attributes.filter[isIsKey] SEPARATOR ", "»«r.name.toLowerCase+"_"+a.name.toLowerCase»«ENDFOR») REFERENCES public.«refTbl.name.toLowerCase» («FOR a : alterTbl.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			«ELSEIF relWithOneGen»
			-- «cardinalityRel»: Relationship with ONE ENTITY that HAS GENERALIZATION
			ALTER TABLE ONLY public.«alterTbl.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase» FOREIGN KEY («FOR a : refTbl.is.attributes.filter[isIsKey] SEPARATOR ", "»«r.name.toLowerCase+"_"+a.name.toLowerCase»«ENDFOR») REFERENCES public.«refTbl.name.toLowerCase» («FOR a : refTbl.is.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			«ELSEIF relNoGen»
			-- «cardinalityRel»: Relationship in which BOTH ENTITIES have NO GENERALIZATION
			ALTER TABLE ONLY public.«alterTbl.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase» FOREIGN KEY («FOR a : refTbl.attributes.filter[isIsKey] SEPARATOR ", "»«r.name.toLowerCase+"_"+a.name.toLowerCase»«ENDFOR») REFERENCES public.«refTbl.name.toLowerCase» («FOR a : refTbl.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			«ENDIF»

	'''

	def private mysql_AlterTable_NtoN_RefMapper(Entity leftEnt, Entity rightEnt, Relation r, Boolean selfRelWithGen, Boolean selfRelNoGen, Boolean relWithOneGen, Boolean relNoGen, String cardinalityRel) '''			
			«IF selfRelWithGen»
			-- «cardinalityRel»: Self-relation WITH generalization
			ALTER TABLE ONLY public.«r.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase+"_"+leftEnt.name.toLowerCase»_1 FOREIGN KEY («FOR a : leftEnt.is.attributes.filter[isIsKey] SEPARATOR ", "»«leftEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_1"»«ENDFOR») REFERENCES public.«leftEnt.name.toLowerCase» («FOR a : leftEnt.is.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			
			ALTER TABLE ONLY public.«r.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase+"_"+rightEnt.name.toLowerCase»_2 FOREIGN KEY («FOR a : rightEnt.is.attributes.filter[isIsKey] SEPARATOR ", "»«rightEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_2"»«ENDFOR») REFERENCES public.«rightEnt.name.toLowerCase» («FOR a : rightEnt.is.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			«ELSEIF selfRelNoGen»
			-- «cardinalityRel»: Self-relation WITHOUT generalization
			ALTER TABLE ONLY public.«r.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase+"_"+leftEnt.name.toLowerCase»_1 FOREIGN KEY («FOR a : leftEnt.attributes.filter[isIsKey] SEPARATOR ", "»«leftEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_1"»«ENDFOR») REFERENCES public.«leftEnt.name.toLowerCase» («FOR a : leftEnt.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			
			ALTER TABLE ONLY public.«r.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase+"_"+rightEnt.name.toLowerCase»_2 FOREIGN KEY («FOR a : rightEnt.attributes.filter[isIsKey] SEPARATOR ", "»«rightEnt.name.toLowerCase+"_"+a.name.toLowerCase+"_2"»«ENDFOR») REFERENCES public.«rightEnt.name.toLowerCase» («FOR a : rightEnt.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			«ELSEIF relWithOneGen»
			-- «cardinalityRel»: Relationship with ONE ENTITY that HAS GENERALIZATION
			ALTER TABLE ONLY public.«r.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase+"_"+leftEnt.name.toLowerCase» FOREIGN KEY («FOR a : leftEnt.is.attributes.filter[isIsKey] SEPARATOR ", "»«leftEnt.name.toLowerCase+"_"+a.name.toLowerCase»«ENDFOR») REFERENCES public.«leftEnt.name.toLowerCase» («FOR a : leftEnt.is.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			«ELSEIF relNoGen»
			-- «cardinalityRel»: Relationship in which BOTH ENTITIES have NO GENERALIZATION
			ALTER TABLE ONLY public.«r.name.toLowerCase» ADD CONSTRAINT fk_«r.name.toLowerCase+"_"+leftEnt.name.toLowerCase» FOREIGN KEY («FOR a : leftEnt.attributes.filter[isIsKey] SEPARATOR ", "»«leftEnt.name.toLowerCase+"_"+a.name.toLowerCase»«ENDFOR») REFERENCES public.«leftEnt.name.toLowerCase» («FOR a : leftEnt.attributes.filter[isIsKey] SEPARATOR ", "»«a.name.toLowerCase»«ENDFOR»);
			«ENDIF»

	'''
	
}